<div dir="rtl"\>

# گزارش آزمایشگاه دوم مهندسی نرم‌افزار - اصول SOLID

این پروژه به منظور تمرین و درک عمیق اصول طراحی شیءگرا، با تمرکز بر اصول **SOLID**، انجام شده است. در این آزمایشگاه، یک اپلیکیشن پیام‌رسان ساده را با افزودن یک سرویس جدید (تلگرام) توسعه داده و سپس با تحلیل مشکلات طراحی اولیه، آن را بازنویسی (refactor) کردیم تا با اصول SOLID سازگار شود.

-----

## مرحله اول و دوم: پیاده‌سازی اولیه و ثبت تغییرات

در مرحله اول، قابلیت ارسال پیام از طریق تلگرام را به پروژه اضافه کردیم. در جدول زیر، تمام تغییرات اعمال شده در این مرحله به تفصیل ثبت شده است.

### جدول ۱: شرح تغییرات دقیق برای پیاده‌سازی اولیه

<table dir='rtl'>
<tbody>
<tr>
<td width="64">
<p><strong>ردیف</strong></p>
</td>
<td width="198">
<p><strong>محل اعمال تغییرات (کلاس/واسط)</strong></p>
</td>
<td width="141">
<p><strong>عنوان تغییر</strong></p>
</td>
<td width="292">
<p><strong>شرحی کوتاه از تغییر</strong></p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۱</strong></p>
</td>
<td width="198">
<p><code>services/MessageService</code></p>
</td>
<td width="141">
<p>افزودن تابع ارسال پیام تلگرامی</p>
</td>
<td width="292">
<p>افزودن یک متد <code>void</code> با عنوان <code>sendTelegramMessage</code> به اینترفیس.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۲</strong></p>
</td>
<td width="198">
<p><code>models/TelegramMessage</code></p>
</td>
<td width="141">
<p>افزودن کلاس TelegramMessage</p>
</td>
<td width="292">
<p>افزودن کلاس <code>TelegramMessage</code> که از کلاس <code>Message</code> ارث‌بری می‌کند.</p>
<p>این کلاس مدل مربوط به پیام‌رسان تلگرام است که برای <code>get</code> و <code>set</code> کردن id مربوط به مبدا و مقصد است.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۳</strong></p>
</td>
<td width="198">
<p><code>services/TelegramMessageService</code></p>
</td>
<td width="141">
<p>افزودن کلاس سرویس پیام تلگرامی</p>
</td>
<td width="292">
<p>افزودن کلاس <code>TelegramMessageService</code> که اینترفیس <code>MessageService</code> را پیاده‌سازی می‌کند.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۴</strong></p>
</td>
<td width="198">
<p><code>services/TelegramMessageService</code></p>
</td>
<td width="141">
<p>افزودن تابع صحت‌سنجی ID تلگرام</p>
</td>
<td width="292">
<p>افزودن یک متد <code>private boolean</code> با عنوان <code>validateId</code> برای بررسی صحت ID.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۵</strong></p>
</td>
<td width="198">
<p><code>services/TelegramMessageService</code></p>
</td>
<td width="141">
<p>افزودن تابع ارسال پیام تلگرامی</p>
</td>
<td width="292">
<p>پیاده‌سازی متد <code>void</code> با عنوان <code>sendTelegramMessage</code> برای ارسال پیام.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۶</strong></p>
</td>
<td width="198">
<p><code>services/SmsMessageService</code></p>
</td>
<td width="141">
<p>افزودن تابع ارسال پیام تلگرامی</p>
</td>
<td width="292">
<p>افزودن یک متد <code>void</code> با عنوان <code>sendTelegramMessage</code> که بدنه‌ی آن خالی است.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۷</strong></p>
</td>
<td width="198">
<p><code>services/EmailMessageService</code></p>
</td>
<td width="141">
<p>افزودن تابع ارسال پیام تلگرامی</p>
</td>
<td width="292">
<p>افزودن یک متد <code>void</code> با عنوان <code>sendTelegramMessage</code> که بدنه‌ی آن خالی است.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۸</strong></p>
</td>
<td width="198">
<p><code>Main</code></p>
</td>
<td width="141">
<p>افزودن گزینه تلگرام به منو</p>
</td>
<td width="292">
<p>افزودن یک <code>println</code> برای نمایش گزینه ارسال پیام تلگرامی به کاربر.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۹</strong></p>
</td>
<td width="198">
<p><code>Main</code></p>
</td>
<td width="141">
<p>افزودن منطق ساخت پیام تلگرام</p>
</td>
<td width="292">
<p>اضافه کردن <code>case 3:</code> به بدنه‌ی <code>switch</code> برای دریافت اطلاعات و ساخت شیء <code>TelegramMessage</code>.</p>
</td>
</tr>
<tr>
<td width="64">
<p><strong>۱۰</strong></p>
</td>
<td width="198">
<p><code>Main</code></p>
</td>
<td width="141">
<p>افزودن منطق ارسال پیام تلگرام</p>
</td>
<td width="292">
<p>اضافه کردن بلوک <code>else if (message instanceof TelegramMessage)</code> برای فراخوانی سرویس تلگرام.</p>
</td>
</tr>
</tbody>
</table>

<br>
<p><b>تعداد کل فایل‌های تغییر یافته یا اضافه شده: ۶</b></p>
<p><b>تعداد کل تغییرات متمایز اعمال شده: ۱۰</b></p>

-----

## مرحله سوم: بررسی اصول SOLID

در این مرحله، کد نوشته شده در مرحله اول را برای شناسایی موارد نقض اصول SOLID تحلیل کردیم.

### جدول ۲: تحلیل پایبندی و نقض اصول SOLID

<table dir='rtl' border="1" cellspacing="0" cellpadding="6">
<thead>
<tr>
<th width="100"><strong>اصل</strong></th>
<th width="150"><strong>نام اصل</strong></th>
<th width="250"><strong>موارد تحقق</strong></th>
<th width="400"><strong>موارد نقض</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><strong>Single Responsibility</strong></td>
<td>
برای هر کدام از مدل‌ها این مورد رعایت شده، هر کدام از مدل‌ها تعدادی متغیر تعریف کرده و توابع setter و getter برای خود تعریف کرده‌اند که نشان می‌دهد که وظیفه‌ی پاسخ‌گویی به همان متغیرهای خود را به‌عهده دارند.
</td>
<td>
برای سرویس‌ها این نکته رعایت نشده. چرا که اولاً هر کلاسی دارد دو تا سرویس مجزا (validation و send) را انجام می‌دهد و لذا دو دلیل مختلف برای تغییر این فایل‌ها وجود دارد. در ضمن، طراحی بد کد (وجود سه تابع در رابطه) باعث شده که حتماً هر کلاسی حتی بد‌ پیاده‌سازی، تابعی که خودش پیاده‌سازی نمی‌کند، آن تابع را خالی بگذارد. گویا هر کلاسی اینجا مسئول است که حتماً پیاده‌سازی‌ای درباره سایرین هم داشته باشد.
</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>Open-Close Principle (OCP)</strong></td>
<td>
مدل‌ها این ویژگی را دارند، چرا که اگر قرار باشد مدل جدیدی برای <code>extend</code> کردن اضافه کنیم، مشابه ایمیل می‌توان متغیرهای خودش را تعریف کرد و <code>getter</code> و <code>setter</code> و خروجی‌ها را هم نوشت؛ یا اگر مثلاً در خود فایل <code>Message</code> مورد جدیدی اضافه کنیم، بدون نیاز به تغییر فایل ایمیل و ... می‌توان این کار را انجام داد.

اما نکته کلیدی‌تر این است که فایل <code>Message</code> به‌قصد ارسال پیام، علاوه بر متدهای پیام، ورودی و خروجی هم دارد اما متأسفانه هر فرزندی جداگانه همه را تکرار کرده. این یعنی اگر قرار باشد یک تغییری، مانند تغییر در <code>getter</code> مربوط به ورودی پیام انجام شود، وقت باید برای تک‌تک فایل‌ها مثل ایمیل، sms، ... اعمال گردد چون که این‌ها به درستی در کلاس پدر گذاشته نشده بودند.
</td>
<td>
در کلاس <code>Main</code> این اصل رعایت نشده، چرا که برای اضافه کردن سرویس جدید مانند تلگرام، نیاز به افزودن شرط <code>if</code> یا <code>switch case</code> و تغییر مستقیم در کلاس است. یعنی فایل موجود باید ویرایش شود و نه فقط توسعه داده شود. این موضوع دقیقاً نقض اصل Open-Closed است.
</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>Liskov Substitution Principle (LSP)</strong></td>
<td>
همه‌ی کلاس‌های پیاده‌سازی‌شده از واسط <code>MessageService</code> ارث‌بری کرده‌اند و متدهای آن را بدون خطا و به شکل کامل پیاده‌سازی کرده‌اند، بنابراین می‌توان بدون تغییر در کد، هرکدام را جایگزین دیگری کرد.
</td>
<td>
موردی از نقض این اصل مشاهده نشد.
</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>Interface Segregation Principle (ISP)</strong></td>
<td>
در حال حاضر اینترفیس <code>MessageService</code> فقط متدهای اصلی و مشترک را در خود دارد و بیش از حد بزرگ نشده است.
</td>
<td>
اگر در آینده متدهای خاص برای هر سرویس اضافه شود (مثل زمان‌بندی در ایمیل یا ارسال فایل در تلگرام)، اینترفیس به‌ناچار باید متدهایی را داشته باشد که برای برخی کلاس‌ها بی‌معنی است. این موضوع با اصل تفکیک واسط در تضاد است.
</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>Dependency Inversion Principle (DIP)</strong></td>
<td>
در لایه‌ی سرویس‌ها، کلاس‌ها از abstraction یعنی واسط <code>MessageService</code> استفاده کرده‌اند که با این اصل سازگار است.
</td>
<td>
کلاس <code>Main</code> به جای اینکه به abstraction وابسته باشد، مستقیماً به کلاس‌های پیاده‌سازی‌شده مثل <code>EmailMessageService</code> و <code>TelegramMessageService</code> وابسته است. بنابراین با اضافه شدن هر سرویس جدید، باید در <code>Main</code> تغییر ایجاد شود که نقض این اصل است.
</td>
</tr>
</tbody>
</table>

-----

## مرحله چهارم: راهکار برای رفع نقض اصول SOLID

برای هر یک از موارد نقض شناسایی شده، یک راه حل ارائه کردیم.

### جدول ۳: علت نقض و راه حل پیشنهادی
<table dir='rtl' border="1" cellspacing="0" cellpadding="6">
<thead>
<tr>
<th width="150"><strong>اصل مربوطه (از اصول SOLID)</strong></th>
<th width="200"><strong>علت نقض</strong></th>
<th width="400"><strong>راه حل پیشنهادی</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SRP</strong></td>
<td>
در واسط‌ها دو کار مجزا <code>validate</code> و <code>send</code> انجام می‌شود.
</td>
<td>
برای واسط، می‌توان دو تا interface جداگانه، یکی برای <code>send</code> و یکی برای <code>validate</code> تعریف کرد تا این شرط برقرار شود.

<br><br>

همچنین، این راه حل را ارائه می‌کنیم که واسط پدر یک تابع کلی داشته باشد که هر یک از فرزندان نخواهد همان تابع پدر خود را پیاده‌سازی کند. (به‌جای اینکه پدر تمام توابع فرزندان خود را داشته باشد، بعداً هر فرزند توابع سایرین را داخل کلاس خودش را خالی بگذارد).
</td>
</tr>
<tr>
<td><strong>OCP</strong></td>
<td>
در مدل‌ها می‌بینیم بهتر است <code>source</code> و <code>target</code> در پدر قرار داده شوند. در واسط‌ها هم توابع ارسال به‌صورت جدا نیامده‌اند.
</td>
<td>
برای مدل‌ها، می‌توان آیتم ورودی و خروجی را به سمت پدر خود move کرد چون‌که در این پیاده‌سازی فعلی، لزومی بر جداسازی آن‌ها دیده نشده.

<br><br>

در آینده لازم نیست متغیر مبدا و مقصد را در مدل‌های فرزند تکرار کنیم. همچنین در واسط، توابع ارسال پیام را باید به صورت مجزا و متناسب با نوع پیام از یک abstraction عمومی بخوانیم.
</td>
</tr>
<tr>
<td><strong>ISP</strong></td>
<td>
همه‌ی سرویس‌ها مجبور به پیاده‌سازی توابعی هستند که ممکن است برایشان بلااستفاده باشد.
</td>
<td>
به جای یک اینترفیس کلی، اینترفیس‌ها را بر اساس نوع عملکرد جدا کنیم. مثلاً یک اینترفیس برای ارسال پیام متنی، یکی برای پیام دارای فایل، یکی برای زمان‌بندی و ...

<br><br>

در این صورت هر کلاس فقط به آن اینترفیس‌هایی متصل خواهد شد که واقعاً به آن‌ها نیاز دارد.
</td>
</tr>
<tr>
<td><strong>DIP</strong></td>
<td>
کلاس <code>Main</code> وابسته به کلاس‌های پیاده‌سازی‌شده است، نه abstraction.
</td>
<td>
به جای ساخت مستقیم کلاس‌ها در <code>Main</code>، می‌توان از یک Factory یا Dependency Injection استفاده کرد تا وابستگی به کلاس‌های خاص حذف شود.

<br><br>

اینگونه <code>Main</code> فقط به واسط‌ها وابسته می‌شود و اضافه شدن سرویس جدید نیاز به تغییر در آن ندارد.
</td>
</tr>
</tbody>
</table>

-----

## مرحله پنجم: بازنویسی کد بر اساس اصول SOLID

در این مرحله، راه حل‌های پیشنهادی را در کد اعمال کردیم. کد نهایی در پوشه `step2-with-solid` قرار دارد و شامل کلاس‌های Factory برای ایجاد `Message` و `Sender` است که وابستگی‌ها را از کلاس `Main` حذف کرده و اصول OCP و DIP را برقرار می‌کند. همچنین با تفکیک اینترفیس‌ها، اصل ISP نیز رعایت شده است.

-----

## پاسخ سوالات پایانی

۱. **اگر اصول SOLID از ابتدا برقرار بود، ۵ مورد از ۱۰ تغییر ثبت شده در جدول حذف می‌شد.** دیگر نیازی به تغییر اینترفیس `MessageService`، کلاس `SmsMessageService`، کلاس `EmailMessageService` و منطق اصلی در کلاس `Main` نداشتیم.
در نهایت، سرویس جدید تنها با **۵ تغییر** در سطح کد اضافه می‌شد: ایجاد کلاس‌های `TelegramMessage` و `TelegramSender` و افزودن یک خط به `Main` (برای منو) و هر کدام از دو کلاس Factory جدید.

۲. **رعایت اصول شی‌گرایی با کاهش وابستگی بین کلاس‌ها، کد را به شدت قابل نگهداری می‌کند،** بنابراین یک تغییر در یک بخش نیازمند اصلاح چندین فایل دیگر نخواهد بود. این امر پروژه را به طور قابل توجهی **توسعه‌پذیرتر** می‌کند، زیرا ویژگی‌های جدید را می‌توان با اطمینان و بدون ریسک شکستن کدهای پایدار موجود، اضافه کرد.
حتماً. در ادامه ترجمه دقیق‌تر پاسخ سوال دوم با مثال‌های مشخص از پروژه شما آمده است:

رعایت اصول شی‌گرایی دو مزیت اصلی برای این پروژه فراهم می‌کند: **بهبود قابلیت نگهداری** و **افزایش توسعه‌پذیری**.

**قابلیت نگهداری (Maintainability):** با جداسازی (decoupling) کلاس سطح بالای `Main` از کلاس‌های سطح پایین `Sender` (مانند `SmsSender` و `EmailSender`)، نگهداری کد بسیار آسان‌تر می‌شود. به عنوان مثال، اگر نیاز به تغییر منطق داخلی `SmsSender` داشته باشیم، می‌توانیم با اطمینان این کار را انجام دهیم، زیرا می‌دانیم تغییرات ما به طور تصادفی کلاس `Main` را دچار مشکل نخواهد کرد، چون `Main` دیگر به طور مستقیم به آن وابسته نیست.

**توسعه‌پذیری (Extensibility):** طراحی بازسازی‌شده به طور قابل توجهی توسعه‌پذیرتر است. برای افزودن یک سرویس جدید مانند «واتس‌اپ»، دیگر نیازی به تغییر کلاس `Main` که در حال کار است نداریم (پیروی از اصل OCP). کافی است یک مدل جدید `WhatsAppMessage` و یک سرویس `WhatsAppSender` ایجاد کرده و سپس آن‌ها را در فکتوری‌های خود ثبت کنیم. این کار به سیستم اجازه می‌دهد تا با اطمینان و بدون ریسک وارد کردن باگ به منطق اصلی برنامه، رشد کند.
  
</div>
